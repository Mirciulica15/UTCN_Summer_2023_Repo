# Control groups

Also referred to as **cgroups**.

There are 2 types of control groups:

- 2007: Version 1

- 2013: Version 2 work started

In 2019, finally Fedora implemented Version 2.

Control groups allow you to specify the **resources** available to process **hierarchies**.

## Memory cgroup

It keeps count of the memory usage (memory pages used by each group).

Granularity: page (usually 4KB).

The pages are sorted between different types:

- **file**: read/write/mmap from block devices -> you can track them to a specific location on disk (this is **IMPORTANT** because if you desperately need memory, you can **swap out** this "file" type, because you know it is also on the disk)

- **anonymous**: stack/heap/anonymous mmap -> this is a bit more annoying when trying to reclaim

There are 2 pools of memory:

- **active** (recently accessed) -> by default we put them all in active

- **inactive** (candidate for eviction) -> when we have problems with memory, we get close to the limit

When multiple groups use the **same** page, they don't equally split the bill, but 1 group has the entire bill. But if that group is stopped, then the charge is **moved** to another group.

You can set limits (**soft** and **hard**).

Hard limits trigger a per-group **OOM killer**.

The more you are above the soft limit, the more likely you are to have pages taken away from you by the kernel.

You can also set limits for the **kernel memory**.

You can also avoid the OOM killer by **freezing** all the processes in the group and notifying the user.

**HugeTLB cgroup** -> this cgroup is for **huge** pages.

## CPU cgroup

Keeps track of user/system CPU time and of usage per CPU!

Allows to set **weights**.

Can't set CPU **limits**! Why?

![NoCpuLimitExplanation](https://github.com/Mirciulica15/UTCN_Summer_2023_Repo/assets/36898665/e27ce5d8-701f-4ede-ba73-bcdc3e949af9)

## Cpuset cgroup

**Pin** groups to specific CPU(s).

**Reserve** CPU for specific apps.

It can be useful when you have **multiple** CPUs and **multiple** memories connected to each CPU. You can specify your process which uses a speicic memory to run on the **closest** CPU.

## Blkio cgroup

Block I/O.

Keeps track of I/Os for each group

- per block device

- read vs write

- sync vs async

Set **throttle** (limits) for each group

- per block device

- read vs write

- ops vs bytes

Set **relative weights** for each group.

_Note:_ most writes go through the **page cache** (so classic writes will appear to be unthrottled at first).

## Net_cls and net_prio cgroup

Automatically set traffic class or **priority**, for traffic generated by processes in the group.

## Devices cgroup

Controls what the group can do on **device nodes**.

**Permissions** include read/write/mknod.

![DeviceCgroupPermissions](https://github.com/Mirciulica15/UTCN_Summer_2023_Repo/assets/36898665/3b0a745c-525a-46b6-8619-74fda38a4ccb)

## Freezer cgroup

**Crowd control**.

Allows to **freeze/thaw** a group of processes.

Similar in functionality to SIGSTOP/SIGCONT.

**Cannot be detected** by the processes, that's how it differs from SIGSTOP/SIGCONT.

## Subtleties

PID 1 is placed at the root of each hierarchy.

New processes start in their parent's groups.

pseudo-fs = pseudo filesystem

Groups are **materialized** by pseudo-fs, typically mounted in /sys/fs/cgroup.

Groups are created by **mkdir** in the pseudo-fs:
```bash
mkdir /sys/fs/cgroup/memory/somegroup/subcgroup
```

So, in order to move a process, you just have to do:

```bash
echo $PID > /sys/fs/cgroup/.../tasks
```
