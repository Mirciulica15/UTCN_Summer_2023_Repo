# The Commit Stage

The commit stage begins with a **change** to the state of the project.

It ends with either a report of **faiure** or, if successful, a collection of binary **artifacts** and deployable assemblies to be used in subsequent test and release stages, as well as **reports**.

![image](https://github.com/Mirciulica15/UTCN_Summer_2023_Repo/assets/36898665/6ab50506-2237-471f-8acd-1c3a585a6e20)

<br>

## Commit Stage Principles and Practices

### _Provide Fast, Useful Feedback_

Errors are easiest to **fix** if detected **early**.

Modern CI servers also provide the function called **pretested commit**, that runs the commit stage before check-in.

A common **mistake** is to take the doctrine of **"fail fast"** a little too literally and fail the build immediately when an error is found. This is optimized **too far**. We only stop the commit stage if an error prevents the rest of the stage from running. Otherwise, we run the commit stage to the end and report all the **errors** so they can all be **fixed at once**.

<br>

### _What Should Break the Commit Stage_

- compilation fails, tests breaks, environmental problem

- proide threshold (example: fail if unit test coverage drops below 60%)

_"Failing the Build for Warnings and Code Style Breaches"_ (previous chapters)

<br>

### _Tend the Commit Stage Carefully_

A **poor** build script **draws** vluable and expensive development effort and **slows** the project down.

Ensure that your scripts are **modular**. (Chapter 6 - Build and Deployment Scripting)

Keep tasks that are changing **often** from those that are changing **rarely**.

**Avoid environment-specific scripts!**

<br>

### _Give Developers Ownership_

Adding new libraries, configuration files, and so on, should be performed by **developers** and **operations** people working together.

The **goal** of specialists is to establish good **structures, patterns, and use of technology**, and to **transfer their knowledge** to the delivery team.

<br>

### _Use a Build Master for Very Large Teams_

Their job is to **oversee** the **maintenance** of the build, but also **encourage** and **enforce** build **discipline**.

Team members should **rotate** through it.

<br>

## The Results of the Commit Stage

The **inputs** are the source code.

The **outputs** are the binaries and reports.

The binaries generated by the commit stage are **precisely** the **same** ones that will be reused throughout the **pipeline**.

<br>

### _The Artifact Repository_

This is where you **store** artifacts.

- it ony keeps **successful versions**

- we must be able to **trace back** from the released software to the revisions in VC that were used to create it

- the binary **creation** process must be **repeatable**

![image](https://github.com/Mirciulica15/UTCN_Summer_2023_Repo/assets/36898665/fbbc729a-7ed4-4d9d-879c-b9c6783f5d47)

RC = _release candidate_

Depending on the project, it might make sense to run some of the **post-acceptance-stage** steps **in parallel**.

For example, **manual** testing and **capacity** testing can both be triggered by the successful completion of the acceptance tests.

<br>

## Commit Test Suite Principles and Practices

![image](https://github.com/Mirciulica15/UTCN_Summer_2023_Repo/assets/36898665/ecad5dbf-677c-417c-bf49-2f9e6739a521)

**Unit tests must be fast!**

**Unit tests shouldn't touch** the filesystem, databases, libraries, framework, or external systems.

Any calls to these parts should be replaced with **test doubles**, such as **mocks** and **stubs**.

<br>

### _Avoid the User Interface_

Avoid these [patterns](https://bryanwilhite.github.io/the-funky-knowledge-base/entry/kb2076072213/) !

**UI testing** if often **problematic** and usually better handled at the **acceptance** test stage.

<br>

### _Use Dependency Injection_

![image](https://github.com/Mirciulica15/UTCN_Summer_2023_Repo/assets/36898665/64fc1c87-1d73-443a-b7c0-d7d654dd4d1a)

<br>

### _Avoid the Database_

<br>

### _Avoid Asynchrony in Unit Tests_

Tests which rely on **infrastructure** count as **component** tests, not unit tests.

<br>

### _Using Test Doubles_

```
class Car {
  private Engine engine;

  public Car(Engine engine) {
    this.Engine = engine;
  }

  public void drive() {
    engine.start();
    engine.accelerate();
  }
}

Interface Engine() {
  public start();
  public accelerate();
}
```

We want to test whether the 2 methods (start() and accelerate(), from the Engine) work (sequentially) when the drive() method from Car is called.

1. **Stubbing** is the replacement of a part of a system with a simulated version that provides canned responses.

```
class TestEngine implements Engine {
  boolean startWasCalled = false;
  boolean acceleratedWasCalled = false;
  boolean sequenceWasCorrect = false;

  public start() {
    startWasCalled = true;
  }
  public accelerate() {
    accelerateWasCalled = true;
    if(startWasCalled == true) {
      sequenceWasCorrect = true;
    }
  }
  public boolean wasDriven() {
    return startWasCalled && accelerateWasCalled && sequenceWasCorrect;
  }
}

class CarTestCase extends TestCase {
  public void testShouldStartThenAccelerate() {
    TestEngine engine = new TestEngine();
    Car car = new Car(engine);

    car.drive();

    assertTrue(engine.wasDriven());
  }
}
```

<br>

2. **Mocking** is a newer technique, which doesn't require writing lots of stub code.

```
import jmock;

class CarTestCase extends MockObjectTestCase {
  public void testShouldStartThenAccelerate() {
    Mock mockEngine = mock(Engine);
    Car car = new Car((Engine)mockEngine.proxy());

    mockEngine.expects(once()).method("start");
    mockEngine.expects(once()).method("accelerate");

    car.drive();
  }
}
```

**Mocking** can save a lot of effort.

<br>

### _Minimizing State in Tests_

The **ideal** test is **quick** and **easy** to set up and even quicker and easier to tear down.

<br>

### _Faking Time_

Perhaps your system needs to trigger an end-of-day process, or it needs to wait 500ms before processing the next step.

We need to **abstract** our need for time information into a separate class that is under our control.

<br>

### _Brute Force_

The commit stage **duration** must be **balanced** with the ability to **identify** the most common **errors** that you are likely to introduce.

The commit stage should not last more than 10 minutes! (ideally under 5 minutes)

If it lasts long:

- the developers with check-in **less frequently** (BAD)

- people **stop caring** about whether or not the commit test suite passes (BAD)

<br>

## Summary

The commit stage is focused on 1 thing: **detecting, as fast as possible, the most common failures** and **notifying the developers**.

The commit stage should run every time someone introduces a **change** to the applcation's **code** or **configuration**.
